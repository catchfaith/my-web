---
title: 2025的第一篇文章
date: 2025-02-28 13:40:05
categories: CSharp
---
# 一、开篇
## By the way 好久没有写博客了，之前没有写是因为工作忙碌没有时间，在家待业了小半年，更加懒散了，不能这样下去了，即使找不到方向起码让自己活动起来，今天来就之前遇到的几个面试题来梳理一下，并且看看有没有自己缺乏的再复习一下。

## 1.快速排序的几种算法
### 其实今天也是想了解一下时间复杂度，感觉直接上理论也不太能明白，借鉴几种快速排序的算法来看懂时间复杂度
|  排序算法   | 时间复杂度  |稳定性  |基本思想  |
|  ----  | ----  |----  |----  |
| 冒泡排序  | O(n²) |稳定  |它通过重复地遍历待排序的列表，比较相邻的元素并交换它们的位置来实现排序。该算法的名称来源于较小的元素会像"气泡"一样逐渐"浮"到列表的顶端  |
| 选择排序  | O(n²) |不稳定  |每次从待排序的数据中选择最小（或最大）的元素，放到已排序序列的末尾，直到全部数据排序完成  |
| 插入排序  | O(n²) |稳定  |插入排序通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入  |
| 希尔排序  | O(n log n) |时间复杂度  |希尔排序是插入排序的一种改进版本，也称为缩小增量排序。它通过将待排序的列表分成若干子列表，对每个子列表进行插入排序，逐步缩小子列表的间隔，最终完成  |
| 归并排序  | O(n log n) |稳定  |归并排序的核心思想是将一个大问题分解成若干个小问题，分别解决这些小问题，然后将结果合并起来，最终得到整个问题的解  |
| 快速排序  | O(n log n) |时间复杂度  |定义一个基数按照递归进行排序  |
| 堆排序  | O(n log n) |时间复杂度  |堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序  |
| 计数排序  | O(n+k) |稳定  |计数排序是一种非比较型的排序算法，适用于对整数或有限范围内的数据进行排序。它的核心思想是通过统计每个元素的出现次数，然后根据统计结果将元素放回正确的位置。计数排序的时间复杂度为 O(n + k)，其中 n 是待排序元素的数量，k 是数据的范围大小。  |
| 桶排序  | O(n+k) |稳定  |桶排序是一种分布式排序算法，它将待排序的元素分配到若干个桶（Bucket）中，然后对每个桶中的元素进行排序，最后将所有桶中的元素按顺序合并。桶排序的核心思想是将数据分到有限数量的桶中，每个桶再分别排序（可以使用其他排序算法或递归地使用桶排序）  |
| 基数排序  | O(n+k) |稳定  |通过比较个位数百位数等等来排序  |、


## 2.时间复杂度
### 在之前阅读过大话数据结构的时候我就没有看太懂这个时间复杂度，借用一下deepseek的发言来好好理解一下时间复杂度吧！

### 时间复杂度的定义应该是用来衡量算法运行时间长短的一个指标吧？不过它不是具体的秒或者毫秒，而是用大O符号来表示的，比如O(n)、O(log n)之类的。
___
### 常见的时间复杂度量级
- 常数阶O(1)
>没有循环或者复杂结构
```C#
int i = 0;
int j = 1;
```
- 对数阶O(logN)
```C#
int i = 1;
while(i<n>){
    i = i * 2;
}
```
>从上面的代码看每次循环都会将i*2，i会按照平方的速度接近n，假设再经过x次循环后i大于n那么2^x >= n
x = log2^n
- 线性阶O(n)
>一个数组有n个元素 循环n次 消耗时间随着n的增长而增长
- 线性对数阶O(nlogN)
```C#
for (m=1;m<n;m++>){
int i = 1;
while(i<n>){
    i = i * 2;
}
}
```
>其实就是在外面加了一个线性阶
- 平方阶O(n²)
>常见的冒泡两个循环就是n^2
- 立方阶O(n³)
>三次n循环
- k次方阶O(n^k)
- 指数阶O(2^n)
## 3.dotnet core的依赖注入
### 3.1 这个在之前一次面试中有被问到过其实问出来回答都能答的出来 有单例 瞬时 作用域但是要单独拿出来说那么就感觉不清不楚的了
- 单例
>这个好理解 假设依赖注入了一个Class A 每个http请求进来拿到的这个A都是一个新的A，我这里说的是项目部署后，不同的项目部署就是不一样的了。
- 瞬时
>这个也好理解 每一次得到的Class A都是不同的
- 作用域
>这个当时就有点迷糊了，后面问过了徐子艺大牛得知按照每个http来划分作用域，比如使用dbcontext来形容，每一个请求进来都是同一个连接池，不同http进来的dbcontext都是不一样的。但是衍生出我的另一个想法，假设在一个项目中人流多，可能会有百万级别的访问量那么每一个http中的dbcontext会不会都会连接一次，这里我特地问了下chartgpt解开了我这个迷惑，一般连接是dbcontext内部的连接池来管理的，并不是每个请求都会去连接一次

## 4. redis的宕机问题
### 再简历中有写到过使用redis的锁来防止超卖的行为，但是在被问到加锁之后，redis服务宕机了锁没有释放怎么处理，其他人都进不来 只能等过期时间后自动释放锁。


## 5. tcp和udp的区别
## TCP是面向连接的，提供可靠传输，确保数据有序且无丢失，适用于文件传输等。UDP无连接，速度快但不保证可靠性，适用于视频直播、DNS查询等需低延迟的场景。

