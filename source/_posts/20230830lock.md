---
title: CSharp_lock深入浅出
date: 2023-09-03 10:21:05
categories: CSharp
---

## 20230830
上次看到简历里写的分布式锁在面试官整的哑口无言了，探探到底是分布式锁

首先模拟一个抢票的功能，这里就是用C#来实现好了

```C#
    public static int ticket = 100;
    public async static Task Main(string[] args)
    {
        //假设电影院一共有100长票
        for (int i = 0; i < 5; i++)
        {
            new Thread(() =>
            {
                
                    while (ticket > 0)
                    {
                        Thread.Sleep(100);
                        ticket--;
                        var s = Thread.CurrentThread.ManagedThreadId.ToString("00");
                        Console.WriteLine($"线程{s}拿到一张票！还剩{ticket}张票");
                    } 
           
                
                
            }).Start();
        }
    }
```
查看输出
![Test](/images/lock01.png)
??为啥会同时抢完剩余都是12张呢
因为两个线同时拿到的都是一个值 然后对于这个--操作其实都是对13进行的 如何避免呢？
在单体架构中其实我们可以直接使用lock锁
那么为什么使用lock锁就可以呢？

我们拨开底层来看看
![Test](/images/lock02.png)

但是这种方法对于线程而言是ok的对于进程来说还是不安全
什么意思呢？
例如你一个项目部署了多个实例，那么依然理论上是不安全的

>ps:面试的时候有问到像之前的项目在库存加减的地方用到了redis锁的问题，回答的有点含糊，细想之前写的代码为什么那个地方要用redis来加锁，思考许久目的也就是为了避免脏读数据，简历中写的是避免高并发而去加锁，但是这种手段会在同一个时刻一个进并且拒绝了其他的请求，很显然这并不是处理遇到高并发的很好的手段，那么先从避免数据脏读的角度来分析，这个应该如何去解决呢？
1.在针对与1台服务器的时候可以直接从代码的层面去处理，比如加lock锁，同时有10个请求进行减库存的操作，1个请求进去就会把门关上，另外9个就会等待阻塞。这只是一种方案
2.redis锁也是一种，这个针对与我之前写的加锁代码还需要改进，
![Test](/images/lock03.png)
如图写的代码，假设10个请求同时进，那么另外9个就会直接返回，很显然这是一个不作为的方案，那么要如何改进呢？




