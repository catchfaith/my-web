---
title: 数据库优化
date: 2022-06-13 15:07:05
categories: Sql
---

### 数据库优化
- 1.1 因为数据库要存储比较大的数据 那么再创建表的时候宽度尽可能的精确一些 以免不必要的空间浪费
- 1.2 用join代替子查询 因为**子查询会再内存里面建立一张临时表**，在索引的字段上查询会更快
- 1.3 使用Union来代替手动创建临时表,union是mysql4.0提出来的 它可以将集合查询合并到一个查询中客户端查询会话结束的时候临时表就会被删除
- 1.4 使用事务
   - A : (Atomic)，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；
   - C : (Consistent)，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；
   - I : (Isolation)，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；
   - D : (Duration)，持久性，即事务完成后，对数据库数据的修改被持久化存储。
- 1.5 锁定表，由于在执行事务期间，数据库将会被锁定，这在用户多的情况下会产生很严重的延迟，使用lock table锁定表，锁定表可以保证在锁表unlock table之前不会有其他访问对table进行操作
- 1.6 使用外键
   - 在锁定表的时候为了维护数据的完整性，使用外键可以达到这个效果
- 1.7 使用索引 : 索引一般建立与where join order by 的字段上，不要再有过多重复的字段上建立索引
- 1.8 创建索引
>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引

- 1.9 复合索引
>比如有一条语句是这样的：select * from users where area='beijing' and age=22;
如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。
如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。

- 2.0.索引的字段不能包含null值
>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。
- 2.1 使用短索引
>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
- 2.2 排序的索引问题
>mysql一条语句只会使用1个索引，比如一条sql 有where 有order by 那么命中了where 那么order上的索引就失效了，所以再基本数据库排序能满足的情况下的不要使用排序，尽量不要包含多个列的排序，如果需要那么就给这些列增加复合索引。
- 2.3 like语句的操作
>一般情况下不鼓励使用like去做模糊查询 如果非使用不可 like ‘%aaa%’不会命中索引 但是like'aaa%'可以命中索引
- 2.4 不要在列上进行运算
>比如 select * from A where Year(create_time)>'2003'
会对每一列进行运算
可以使用 select * from A where create_time>'2001-01-01'
- 2.5 不使用not in 和 <> 操作
>这两个都不会命中索引 会进行全表操作
not in 可以not exists代替 
id<>3则可以使用id>3 or id<3来代替
